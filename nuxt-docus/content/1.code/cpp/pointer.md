---
icon: vscode-icons:file-type-cpp2
---

# 指针

## 简述 C++ 中智能指针的特点

shared_ptr, 关于shared_ptr使用需要记住什么？

* 尽量避免使用raw pointer构建shared_ptr，至于原因此处不便于多讲，后续还有讲解
* shared_ptr使得依据共享生命周期而经行地资源管理进行垃圾回收更为方便
* shared_ptr对象的大小通常是unique_ptr的两倍，这个差异是由于Control Block导致的，并且shared_ptr的引用计数的操作是原子的，这里的分析也会在后续看到
* 默认的资源销毁是采用delete，但是shared_ptr也支持用户提供deleter，与unique_ptr不同，不同类型的deleter对shared_ptr的类型没有影响。

C++程序设计中使用堆内存是非常频繁的操作。C++11中引入了`智能指针`的概念，方便管理`堆内存`。
使用`普通指针`，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。
从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。
智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。
另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。
智能指针还有一个作用是把值语义转换成引用语义

## C++ 中智能指针和指针的区别是什么？

智能指针是指在C++中，用于管理堆内存资源的特殊类型的指针。智能指针与普通指针的区别在于，智能指针会自动管理内存资源的分配和释放，以避免内存泄漏和空指针异常。

普通指针是指在C++中，指向内存中的某个地址的变量。普通指针可以指向任意类型的内存资源，并通过解引用运算符*访问指针指向的内存资源。但是，普通指针不会自动管理内存资源，程序员需要自己手动分配和释放内存，否则可能会导致内存泄漏和空指针异常。

例如，下面是一个使用普通指针的示例程序：

```cpp
#include <iostream>

int main() {
  int* p = new int(5);
  std::cout << *p << std::endl;
  delete p;

  return 0;
}
```

在这个程序中，我们定义了一个指针`p`，并使用动态内存分配运算符`new`为它分配了一个新的内存空间，并将值`5`赋值给它。然后我们通过解引用运算符`*`访问指针指向的内存空间，并将它的值输出到标准输出流。最后，我们使用`delete`运算符释放指针所指向的内存空间，避免内存泄漏。

这个程序的运行结果是输出数字`5`，然后正常退出。但是，如果我们没有正确释放指针所指向的内存空间，就会导致内存泄漏，从而影响程序的性能和稳定性。

为了避免这种情况的发生，我们可以使用智能指针。智能指针是指在C++中，用于管理堆内存资源的特殊类型的指针。智能指针会自动管理内存资源的分配和释放，以避免内存泄漏和空指针异常。

例如，下面是一个使用智能指针的示例程序：

```cpp
#include <iostream>
#include <memory>

int main() {
  std::unique_ptr<int> p(new int(5));
  std::cout << *p << std::endl;

  return 0;
}
```

在这个程序中，我们使用了C++标准库中的std::unique_ptr智能指针类型。我们使用这个类型的构造函数，创建了一个新的智能指针，并为它分配了一个新的内存空间，并将值5赋值给它。然后我们通过解引用运算符*访问指针指向的内存空间，并将它的值输出到标准输出流。

在这个程序中，我们没有手动释放指针所指向的内存空间，但是由于我们使用了智能指针，它会在智能指针被销毁时，自动释放指针所指向的内存空间，因此，我们不必担心内存泄漏的问题。

总之，智能指针与普通指针的区别在于，智能指针会自动管理内存资源的分配和释放，以避免内存泄漏和空指针异常。智能指针可以方便程序员管理堆内存资源，提高程序的性能和稳定性。

## 指针和引用的区别是什么？

>
本质：指针是一个变量，存储内容是一个地址，指向内存的一个存储单元。而引用是原变量的一个别名，实质上和原变量是一个东西，是某块内存的别名。  
指针的值可以为空，且非const指针可以被重新赋值以指向另一个不同的对象。而引用的值不能为空，并且引用在定义的时候必须初始化，一旦初始化，就和原变量“绑定”，不能更改这个绑定关系。

* 引用必须被初始化，指针不必。
* 引用初始化以后不能被改变，指针可以改变所指的对象。
* 不存在指向空值的引用，但是存在指向空值的指针。

## 简述数组与指针的区别？

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

* 修改内容上的差别

    ```cpp
    char a[] = "hello";
    a[0] = 'X';
    char *p = "world"; // 注意p 指向常量字符串
    p[0] = 'X'; // 编译器不能发现该错误，运行时错误
    ```

* 用运算符`sizeof`可以计算出数组的容量（字节数）。`sizeof(p)` p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C
  语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

    ```cpp
    char a[] = "hello world";
    char *p = a;
    cout << sizeof(a) << endl; // 12 字节
    cout << sizeof(p) << endl; // 4 字节
    ```

  计算数组和指针的内存容量

    ```cpp
    void Func(char a[100]) {
      cout << sizeof(a) << endl; // 4 字节而不是100 字节
    }
    ```
