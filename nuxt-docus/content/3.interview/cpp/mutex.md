---
icon: vscode-icons:file-type-cpp2
---

# 各种锁

## mutex

在多线程程序中，线程之间会共享访问同一个内存空间。这种共享访问可能导致各种问题，例如竞争条件、数据不一致等。为了解决这些问题，我们可以使用互斥量（mutex）进行同步。

互斥量是指一种特殊的线程同步对象，它可以保证同一时刻只有一个线程能够访问某个共享资源。在C++标准库中，互斥量类型是`std::mutex`。使用互斥量的基本流程如下：

1. 在需要同步的代码段之前，锁定互斥量，这个过程称为加锁。
2. 执行需要同步的代码段。
3. 在需要同步的代码段之后，解锁互斥量，这个过程称为解锁。

例如，下面是一个使用互斥量的示例程序：

```cpp
#include <iostream>
#include <mutex>
#include <thread>

std::mutex mutex;
int value = 0;

void increment() {
  mutex.lock();
  ++value;
  mutex.unlock();
}

int main() {
  std::thread t1(increment);
  std::thread t2(increment);
  t1.join();
  t2.join();
  std::cout << value << std::endl;

  return 0;
}
```

在这个程序中，我们定义了一个全局变量value和一个函数increment，它会将value加一。然后我们创建了两个线程，分别执行函数increment。由于两个线程会同时执行这个函数，所以在函数内部，我们使用互斥量mutex进行加锁和解锁，以保证在任何时刻，只有一个线程能够访问value。

在这个程序中，我们使用了互斥量的两个方法：lock和unlock。lock方法用于加锁，如果互斥量当前没有被锁定，那么调用这个方法会锁定互斥量，并立即返回；如果互斥量当前已经被锁定，那么调用这个方法会阻塞线程，直到互斥量被解锁为止。unlock方法用于解锁，如果互斥量当前已经被锁定，那么调用这个方法会解锁互斥量，并立即返回；如果互斥量当前没有被锁定，那么调用这个方法会抛出一个异常。

总之，互斥量是多线程程序中一种重要的同步工具，它可以保证同一时刻只有一个线程能够访问某个共享资源。使用互斥量的流程是：首先在需要同步的代码段之前，锁定互斥量；然后执行需要同步的代码段；最后在需要同步的代码段之后，解锁互斥量。
