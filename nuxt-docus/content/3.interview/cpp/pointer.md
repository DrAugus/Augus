---
icon: vscode-icons:file-type-cpp2
---

# 指针

## 简述 C++ 中智能指针的特点

shared_ptr, 关于shared_ptr使用需要记住什么？

* 尽量避免使用raw pointer构建shared_ptr，至于原因此处不便于多讲，后续还有讲解
* shared_ptr使得依据共享生命周期而经行地资源管理进行垃圾回收更为方便
* shared_ptr对象的大小通常是unique_ptr的两倍，这个差异是由于Control Block导致的，并且shared_ptr的引用计数的操作是原子的，这里的分析也会在后续看到
* 默认的资源销毁是采用delete，但是shared_ptr也支持用户提供deleter，与unique_ptr不同，不同类型的deleter对shared_ptr的类型没有影响。

C++程序设计中使用堆内存是非常频繁的操作。C++11中引入了`智能指针`的概念，方便管理`堆内存`。   
使用`普通指针`，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。    
从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。     
智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。       
另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。     
智能指针还有一个作用是把值语义转换成引用语义

## C++ 中智能指针和指针的区别是什么？

## 指针和引用的区别是什么？

>
本质：指针是一个变量，存储内容是一个地址，指向内存的一个存储单元。而引用是原变量的一个别名，实质上和原变量是一个东西，是某块内存的别名。  
指针的值可以为空，且非const指针可以被重新赋值以指向另一个不同的对象。而引用的值不能为空，并且引用在定义的时候必须初始化，一旦初始化，就和原变量“绑定”，不能更改这个绑定关系。

* 引用必须被初始化，指针不必。
* 引用初始化以后不能被改变，指针可以改变所指的对象。
* 不存在指向空值的引用，但是存在指向空值的指针。

## 简述数组与指针的区别？

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

- 修改内容上的差别
    ```cpp
    char a[] = "hello";
    a[0] = 'X';
    char *p = "world"; // 注意p 指向常量字符串
    p[0] = 'X'; // 编译器不能发现该错误，运行时错误
    ```
- 用运算符`sizeof`可以计算出数组的容量（字节数）。`sizeof(p)` p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C
  语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
    ```cpp
    char a[] = "hello world";
    char *p = a;
    cout << sizeof(a) << endl; // 12 字节
    cout << sizeof(p) << endl; // 4 字节
    ```
  计算数组和指针的内存容量
    ```cpp
    void Func(char a[100]) {
      cout << sizeof(a) << endl; // 4 字节而不是100 字节
    }
    ```
