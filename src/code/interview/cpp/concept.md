---
index: false
---

# 概念辨析

- [const](./const)

## 编译时链接有几种方式？[静态链接和动态链接的区别](https://www.cnblogs.com/cyyljw/p/10949660.html)是什么？

问题变形，

- 简述 C++ 从代码到可执行二进制文件的过程
- 简述 C++ 编译的过程

answer：

* 编译分为3步
    * 首先对源文件进行预处理，这个过程主要是处理一些#号定义的命令或语句（如宏、#include、预编译指令#ifdef等），生成*.i文件；
    * 然后进行编译，这个过程主要是进行词法分析、语法分析和语义分析等，生成*.s的汇编文件；
    * 最后进行汇编，这个过程比较简单，就是将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件。
* 静态链接
* 动态链接
* 更多细节，[从编写源代码到程序在内存中运行的全过程解析](https://blog.csdn.net/kang___xi/article/details/79571137)

## 转移语义(Move Semantics)

## 左值和右值

## malloc 和 new，free 和 delete 的区别

malloc是函数，而new是关键字。然后new作为C++中动态对象创建的基石，除了完成堆空间的分配操作以外还要完成一些初始化操作，及new的过程中会调用对象的构造函数去初始化，而malloc不会。最后要明确的是malloc分配的内存只能用free来释放，而new分配的地址只能用delete来释放，如果new分配的是数组，则需要delete[ ]
来释放，否则会出现未定义行为。

`delete`会调用对象的析构函数,和`new`对应`free`
只会释放内存，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

`delete` 与 `delete []`区别

delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective
C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator
delete来释放内存。”delete与new配套，delete []与new []配套

```c++
MemTest *mTest1 = new MemTest[10];
MemTest *mTest2 = new MemTest;
Int *pInt1 = new int[10];
Int *pInt2 = new int;
delete[]pInt1; //-1-
delete[]pInt2; //-2-
delete[]mTest1;//-3-
delete[]mTest2;//-4-
```

在-4-处报错。 这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]
不能互用。delete[]
删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]
会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。

## 组合与继承

**组合**

- 优点：
    - 不会破环封装性父类的任何变化不会引起子类的变化
    - 组合运用复杂的设计他们的关系实在程序运行的时候才确定的可以支持动态的组合
    - 整体类可以对局部类的接口进行封装，提供新的接口
- 缺点：
    - 整体类不能自动获得和局部类同样的接口，只有通过创建局部的对象去调用它
    - 创建整体类的时候需要创建局部类的对象

**继承**

- 优点：
    - 子类继承了父类能自动获得父类的接口
    - 创建子类对象的时候不用创建父类对象
- 缺点：
    - 破坏了封装，父类的改变必定引起子类的改变，子类缺乏独立性
    - 支持功能上的扩展，但多重继承往往增加了系统结构的复杂度。
    - 继承是在静态编译的时候就已经确定了关系，不支持动态继承。


## 深拷贝与浅拷贝区别是什么？

* **浅拷贝**：如果在类中没有显式地声明一个[拷贝构造函数](##copyConstructor)，那么，编译器将会根据需要生成一个默认的[拷贝构造函数](##copyConstructor)，完成对象之间的位拷贝。default
  memberwise copy即称为浅拷贝。 此处需要注意，并非像大多数人认为的“如果class未定义出copy constructor，那么编译器就会为之合成一个执行default memberwise copy语义的copy
  constructor”。 通常情况下，只有在default copy constructor被视为trivial时，才会发生上述情况。一个class，如果既没有任何base/member class含有copy
  constructor，也没有任何virtual base class或 virtual functions， 它就会被视为trivial。 通常情况下，浅拷贝是够用的。
* **深拷贝**：然而在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。
  这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。
  因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。

