---
index: false
---

# 概念辨析

- [const](./const)
- [堆栈 内存](./stack_memory)
- [指针](./pointer)
- [引用](./reference)

## 特性 —— 封装 继承 多态

Encapsulation, Inheritance, Polymorphism

**多态**：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：

- 在程序运行时的多态性通过继承和虚函数来体现；
- 在程序编译时多态性体现在函数和运算符的重载上；

**虚函数**：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

**纯虚函数的作用**：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在
纯虚函数不具备函数的功能，一般不能直接被调用。

从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为**抽象类**（abstract class）。

抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

|   继承描述符   |  父public成员   | 父protected成员 | 父private成员 |
|:---------:|:------------:|:------------:|:----------:|
|  public   |  子public成员   | 子protected成员 |     -      |
| protected | 子protected成员 | 子protected成员 |     -      |
|  private  |  子private成员  |  子private成员  |     -      |

1. `public`：只继承基类的接口。当继承是接口的一部分时，就选用public继承。
2. `private`：只继承基类的实现。当继承是实现细节时，就选用private继承。
3. `protected`：当继承是面向派生类而不是面向用户接口中的一部分时，就选用protected继承。 private意味着”根据某物实现出“的语义。和复合拥有同样的语义。

- C++ 中虚函数与纯虚函数的区别
- C++ 的重载和重写是如何实现的？
- C++ 中什么是菱形继承问题？
- 父类和子类是不是在同一个虚函数表
- C++ 中多态是怎么实现的
- 虚表指针的大小
- 虚函数表的存放内容
- 构造函数可以是虚函数吗
- 析构函数可以是虚函数吗

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。       
如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数  
用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。   
存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。       
虚表是和类对应的，虚表指针是和对象对应的。       
多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。       
多态用虚函数来实现，结合动态绑定。       
纯虚函数是虚函数再加上 = 0； 抽象类是指包括至少一个纯虚函数的类。         
纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。

## 编译时链接有几种方式？[静态链接和动态链接的区别](https://www.cnblogs.com/cyyljw/p/10949660.html)是什么？

问题变形，

- 简述 C++ 从代码到可执行二进制文件的过程
- 简述 C++ 编译的过程

answer：

* 编译分为3步
    * 首先对源文件进行预处理，这个过程主要是处理一些#号定义的命令或语句（如宏、#include、预编译指令#ifdef等），生成*.i文件；
    * 然后进行编译，这个过程主要是进行词法分析、语法分析和语义分析等，生成*.s的汇编文件；
    * 最后进行汇编，这个过程比较简单，就是将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件。
* 静态链接
* 动态链接
* 更多细节，[从编写源代码到程序在内存中运行的全过程解析](https://blog.csdn.net/kang___xi/article/details/79571137)

## 转移语义(Move Semantics)

## 左值和右值

## malloc 和 new，free 和 delete 的区别

malloc是函数，而new是关键字。然后new作为C++中动态对象创建的基石，除了完成堆空间的分配操作以外还要完成一些初始化操作，及new的过程中会调用对象的构造函数去初始化，而malloc不会。最后要明确的是malloc分配的内存只能用free来释放，而new分配的地址只能用delete来释放，如果new分配的是数组，则需要delete[ ]
来释放，否则会出现未定义行为。

`delete`会调用对象的析构函数,和`new`对应`free`
只会释放内存，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

`delete` 与 `delete []`区别

delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective
C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator
delete来释放内存。”delete与new配套，delete []与new []配套

```cpp
MemTest *mTest1 = new MemTest[10];
MemTest *mTest2 = new MemTest;
Int *pInt1 = new int[10];
Int *pInt2 = new int;
delete[]pInt1; //-1-
delete[]pInt2; //-2-
delete[]mTest1;//-3-
delete[]mTest2;//-4-
```

在-4-处报错。 这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]
不能互用。delete[]
删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]
会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。

## 组合与继承

**组合**

- 优点：
    - 不会破环封装性父类的任何变化不会引起子类的变化
    - 组合运用复杂的设计他们的关系实在程序运行的时候才确定的可以支持动态的组合
    - 整体类可以对局部类的接口进行封装，提供新的接口
- 缺点：
    - 整体类不能自动获得和局部类同样的接口，只有通过创建局部的对象去调用它
    - 创建整体类的时候需要创建局部类的对象

**继承**

- 优点：
    - 子类继承了父类能自动获得父类的接口
    - 创建子类对象的时候不用创建父类对象
- 缺点：
    - 破坏了封装，父类的改变必定引起子类的改变，子类缺乏独立性
    - 支持功能上的扩展，但多重继承往往增加了系统结构的复杂度。
    - 继承是在静态编译的时候就已经确定了关系，不支持动态继承。

## 深拷贝与浅拷贝区别是什么？

* **浅拷贝**：如果在类中没有显式地声明一个[拷贝构造函数](##copyConstructor)
  ，那么，编译器将会根据需要生成一个默认的[拷贝构造函数](##copyConstructor)，完成对象之间的位拷贝。default
  memberwise copy即称为浅拷贝。 此处需要注意，并非像大多数人认为的“如果class未定义出copy
  constructor，那么编译器就会为之合成一个执行default memberwise copy语义的copy
  constructor”。 通常情况下，只有在default copy constructor被视为trivial时，才会发生上述情况。一个class，如果既没有任何base/member
  class含有copy
  constructor，也没有任何virtual base class或 virtual functions， 它就会被视为trivial。 通常情况下，浅拷贝是够用的。
* **深拷贝**：然而在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。
  这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。
  因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。

## 动态绑定和静态绑定的区别

* 对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
* 对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
* 静态绑定：绑定的是对象的静态类型，某特性(比如函数)依赖于对象的静态类型，发生在编译期。
* 动态绑定：绑定的是对象的动态类型，某特性(比如函数)依赖于对象的动态类型，发生在运行期。

## 变量的声明和定义有什么区别？

**声明**告诉编译器，这个变量或函数已经在程序其他地方存在了，所以我正在把这个信息告诉你，下面我要调用的时候请放行。但请不要为我分配任何内存空间，
因为已经这个步骤在变量或函数定义的地方进行分配了  
而**定义**则很清楚了，就是要求分配内存空间。 很多时候，声明和定义是合而为一的。

```cpp
int a;
void func() {};
```

这里同时声明且定义了一个变量和一个函数。

声明可以进行多次，定义只能进行一次

[more info](https://www.jianshu.com/p/92e81ecc8737)

## 内联函数

## lambda 函数的特点，和普通函数相比有什么优点？

## extern C 的作用

## volatile关键字的作用

## 结构（struct）与联合（union）的区别

- 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）,
  而结构的所有成员都存在（不同成员的存放地址不同）。
- 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

## 重载（`overload`)和重写(`override`，有的书也叫做“覆盖”）的区别？

常考的题目。从定义上来说：

* 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
* 重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

* **重载**：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function
  func(p:integer):
  integer;和function func(p:string):
  integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
* **重写**
  ：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

