# 线程

## 数据互斥

在多线程存在的环境中，除了堆栈中的临时数据之外，所有的数据都是共享的。如果我们需要线程之间正确地运行，那么务必需要保证公共数据的执行和计算是正确的。简单一点说，就是保证数据在执行的时候必须是互斥的。否则，如果两个或者多个线程在同一时刻对数据进行了操作，那么后果是不可想象的。

todo todo todo

那么，有什么办法可以保证在某一时刻只有一个线程对数据进行操作呢？四个基本方法：

1. 关中断
2. 数学互斥方法
3. 操作系统提供的互斥方法
4. cpu原子操作

### 关中断

要让数据在某一时刻只被一个线程访问，方法之一就是停止线程调度就可以了。那么怎样停止线程调度呢？那么关掉时钟中断就可以了啊。在X86里面的确存在这样的两个指令

```c
#include <stdio.h>
int main () {
    __asm {
        cli
        sti
    }
    return 1;
}
```

其中cli是关中断，sti是开中断。这段代码没有什么问题，可以编过，当然也可以生成执行文件。但是在执行的时候会出现一个异常告警：Unhandled exception in test.exe: 0xC0000096:  Privileged Instruction。告警已经说的很清楚了，这是一个特权指令。只有系统或者内核本身才可以使用这个指令。

### 数学互斥方法

假设有两个线程（a、b）正要对一个共享数据进行访问，那么怎么做到他们之间的互斥的呢？其实我们可以这么做

```cpp
unsigned flag[2] = {0};
unsigned turn = 0;

void process (unsigned index) {
    flag[index] = 1;
    turn = index;
    while (flag[1 - index] && (turn == index)) {
        // do something
    }
}
```

### 操作系统提供的互斥方法

### cpu原子操作

## 线程间同步
